---
title: CS247
subtitle: A course on software design.
date: August 12 2016

---

# CS247
### Why object oriented design
* shared vocabulary
* closer to client domain
* raise level of abstraction
* re-use(as is, extended e.g. inheritance)
* modularity (decompose problem into classes)
* information hiding, encapusulate design decisions
* polymorphism **

### Important concepts
* virtual
* pure virtual
* v-table
* baseclass
* superclass
* subclass
* abstract base class
* object slicing
* static data + methods

# Lecture 2 -- ADT Design
We would like our client to only know our ADT through its interface

* range of data, but not its representation
* operations, but not their implementation

## Abstract Data Types (ADTs)

User defined type, bundles:

* range of values that variables of that type can hold
* operations that manipulate variables of that type

 Provides compiler support for your restrictions on values and operations- turns programmer errors into type errors(checked by compiler)

 Can change value range, data representation withotu changin client source code

 **Safety** : restrict values to desired range

 * operations leave data in valid state
 * want "tool" supported safety checked via compiler

### Evolvability

* since client code only depends on interface, implementation can change
  without impacting client

**cohesion**: keep related things together
**coupling**: degree of dependance

### Productivity

* checks data ranges for us but only where required
* constructors, mutability operators

#### When to use
* customize data
* customize operations
* restrict data ranges
* should be used aggressively

## Rational Number

* default constructor
  * valid value == 0 (0/1)
* destructor
  * default is probably ok
* other constructor (allow both, default denominator to 1)
  * default numerator to 0 gets rid of def constrcutor (explicit so it does
    what we want)
* compiler copy constructor is fine
* all these elements part of class because cohesion
* assignment (compiler provided ok)
* arithmetic (overload  +, -, \*, /)
  * r + 3 fine because operation on r
  * 3 + r need way to convert int to rational
* I/O ($\gt\gt$, $\lt\lt$)
  * need to be global because its not acting on a class, rather somthing else
    calls it
* equality
  * should reduce first since we are working with fraction?
  * what about in other operations

### MISC
* Goal: consistent, complete and encapsulated
* return value optimization
    * don't creat copy on `return`

## Legal values

* constructor initializes data members to legal values

## Public Accessors and Mutators

* accessors and mutators provide restricted read/update access to data members
  * want some naming convention
* Best Practice: mutators check  that client-provided values are within ADT value range
* Best Practice: pass parameters by const reference when possible, use const
  member functions

## Function Overloading

* function overloading allows you to use the same function name for variants of
  the same function
  * must have different argument signatures
  * cannot overload functions that differ only by return type

## Default Arguments

* use to combine variants that vary in user provided arguments
* must appear only in the function declaration
* only trailing parameters may have default values
* once one default argument used in function, rest must be default

## Operator Overloading

* design decision: signature of the operator
  * argument types, return type, const, pass byvalue/passbyreference
* best practice: use operator signatures that the client programmer is used to
  (operator== returns bool)
  * cannot create new operations
  * cannot change number of arguments

## NonMember Functions

* critical function of the ADT that is declared outside of the class
  * reduces number of functions with direct access to private data members
  * some functions have to be nonmember functions (e.g. operator>>)
  * if needs access to private can just be friend

## operator>> operator<<

* streaming operators should be nonmember functions so that first operand is
  reference to stream object
* best practice: return value is modified stream, so that stream operations can
  be chained

### Illegal values

* return values
  * old school
  * passive; no enforcement
  * what if part of range
* global error codes
  * passive checks, values can change
* exceptions
  * orthogonal to normal processing code
  * localized

## type conversions

* compiler uses constructors that have one argument to perform implicit type conversion
* explicit so no implicit type conversion

## private data representation

* data members should always be private
* clients just use public accessors mutators so that things can not be set to weird values
* derived classes usually use public/protected members
* ease evolution of the data representation

## Friends

* sometimes want default access to be private, but to grant access to select
  code

## Helper functions

* hide helper functions as private methods or within a namespace
  * modularize code that is common among multiple class-related functions
  * should not pollute global namespace

## Override/Final

* applying override to a method says it overrides
* final to virtual function prevents it from beind overridden in derived
  classes
* final can be applies to class, cant extend

# Lecture 3

## Attributed based ADT

* class interface based entirely on attributes(data members)
* public interface is simply accessors + mutators
* all other functions are non-members
* use "override" keyword as appropriate self documentation

### Entity object

* computer embodiment of real world entity
* each object has a distinct identity
* object with same attribute values are not equal
* i.e. physical objects, people, records, transactions

#### Examples

* phsyical objects: airplane, runway, taxiway
* people: passenger, booking agent
* records: customer information
* transaction: reservation, cancellation, receipts

### Value Object

* simply represents a value of an ADT
* objects with the same values are considered to be identical
* postal code, address, mathematical types etc.

### Design of Entity ADTs

* operation on an entity should reflect a real world event
* copying an entity is not meaningful, program no longer reflects reality
	* operations on copies are uncoordinated and can be lost when copy dissapears
	* prohibit copy constructor
	* prohibit assignment
	* prohibit type conversions
	* avoid equality
* computations on entities are not meaningful
	* think twice b4 overloading operators exept new and delete
	* operator< is useful when overloaded to apply to entity name or unique id
* entities referred by pointers (consequence of no copy rule)

### Design of value ADTs

* equality is important
 	* copy constructor
 	* assignment operator
* comparisons involving value make sense
 	* overload arithmetic operators
	* virtual functions and inheritance uncommon

## Entity or value based ADT

* consider a computer card game such as "straights"

| Object | Entity | Value |
|--------|--------|-------|
|Card | const - | |
| Deck | - | |
| hand | - | |
|player| - | |
|score| | - |

## Mutable objects

* problematic when they can be referenced from two variables
* might be changed externally

## Mutable vs immutable

* entity objects are mutable, change change value via mutators
* value based usually immutable
	* variables of ADT are just assigned a differente object
	* no mutators
	* cannot override member functions
	* copy/assignment are deep copies
	* data private
	* all data primitive or immutable types

## Singleton

* single instance of object
* no way to create another object
* have static member with an instance of the object, get through some static helper that returns that instnace, make constructor private

### Alternative

* use pointer (static); if never used, no allocation
	* public accessor responsible for creation; static as well
	* destructor responsible for deletion

## Student ADT

* entity
	- student id # <- value ADT to enforce range-checking
	- name (length  constraints ? preferrred name? UTF encoding?)
	- gender (0-100, -F - A+, DNW, IC etc)

### License

* 8 including space
* uppercase letters (4) space 3 digits
* default constructor generates next from static data memver
* vanity plates restrict values
* entity

#####Midterm: given some object, entity value, expected operations

## PImpl

* use nested private class to futher hide data
* reduces coupling
* reduces recompilation

```
struct Rational::Impl {
	int numerator;
	int denominator;
}
```
* if mark rational as final, can't inherit
* could makr methods as final to prevent override  no override
* should make shallow so people cant fiddle around with data

# Lecture 4 -- Special Member Functions

## Rule of 3 a.k.a "The big 3"

* copy constructor
* destructor
* assignment operator
* if define (1 or more), probably want to define all 3
* c++11 expands it to rule of 5 by adding concept of "rvalues" modifiable
  temporaries
* identied by T && set up by std::move()
 * double ampersand says modifiable reference
* i.e. add move constructor and move assignemnt to the list
* these plus default destructor provided by compiler unless overriden by user

```
// forward declaration
class Base;
class C;

class MyClass: public Base {
private:
  C comp_;
  C *ptr_;
  int simple_;
public:
  MyClass();
  ~MyClass();
  MyClass(const MyClass&);
  MyClass(const MyClass&&);
  MYClass& operator=(const MyClass&);

}
```

## Compiler Generated Default constructor

* if we do not create, will generate for us
* memberwise initialization
* simple data memebers uninitialized, pointers uninitialized
* member objects and inherited members initilaized using base default
  ocnstructor

## Complier Generated Destructor

* compiler will not deallocate memory value in destructor, but will generate
  automatic destructor
* memberwise destruction
* simple data members deallocated
* pointer memberes deallocated but not deleted
* member objects cleaned up using members' destructors
* inherited members cheaned up using base class's destructor

## Copy constructor

*  constructs new object whose value is equal to an existing object
* used by compiler to copy object os ADT

## Copying objects with pointers

* shallow copy: copies the object and its pointers' addresses so that the
  original and copied pointers refer to the same object
* deep copy:  copies the object and what its pointers point to so that the
  pointer data members refer to distinct copies
* is sharing reasonable or not

## Compiler generated copy constructor

*  get shallow copies by default
* memberwise copy
* simple data bitwise copy
* pointer members bitwise
* member copied using copy constructors
* inherited members copied using base class's copy constructor

## Assignment Operator

* default is shallow
* copy assignment is similar to the copy constructor except desination already exists
* destination of copy already exists

## Compiler Generated Assignment Operator

* memberwise assignment
* simple data members: bitwise copy
* pointer members: bitwise copy
* members and inherited objects use assignment operators


## Copy-Swap Idiom

* assignment operator
* where we fail, before we modify original, we leave original untouched
* make copy of value that you want to put in
* how to do this
* assignment operators may deal with pointer members by:
* swap pointers to object being deleted so it takes care of it
  * creating a new object of same type with copy construtor
  * swapping the old values of hte pointer members with the value in the
    newly created object
  * letting the destructor take care of deleting the old members at the cost
    of efficiency
### Self Assignment
```
MyClass  a;
a = a;
```
* in operator= check that not assigning to same object  i.e. 'other' != 'this'
* if get past test, inboke copy&swap

## Move Constructor

* constructs a new object whose value is equal to an existing object but does
  not preserve the value of the existing object
* need rvalue reference to call this
* std::move()
* memberwise move
* bitwise copies for simple data members pointer members
* uses members move/copy for members and inherited members

## Move Assignment

* destination of the moved from object already exists
* only requirement of moved from object is that it is easy to delete and
  reassign

## How does a compiler know to move or copy

* language rules e.g for return  values, may suggest a move (return
  value optimization
* otherwise, programmer specifies by supplying an rvalue through
    std::move())
  * move returns an rvalue but doesnt do the move

## Equality

* a copied/assigned object shoudl be euqal to the original
* deep equality: check values of pointers
* shallow equality: check references
* copied/assigned object should be equal to the original
* no compiler generated

# Lecture 5: Modules v Namespaces

## Program decomposition

* module may refer to classes variables types functions constants that are defined in another module, must be declared/defined before use
* **Approach 1** programmer of each module declare non global names used by the module
* **Approach 2** put all declarations needed itno header file any module that refers to that class uses header file.
* problem: compilation of single source file may include the same header declarations multiple times

* typically want one file per ADT
* exception where there might be a nested class
* need to share class definitions: declarations
* proper way to use global variables is `extern` keyword

## Globals

* try to restrict yourself to only global constants, and not variables
* use `extern` to mark it => not a space allocation => must remember to
  allocate but only once.
* globals.h
```
extern const int MAX_SIZE;
```
* main.cpp
```
const int MAX_SIZE = 10;
```


## Header files

* have all the declarations we need for a class.
* hide as much as possible, only show what you need

## Guards

* use preprocessor macros and the compiler to ensure only ever 1 definition

```
#if
#endif
#ifdef
#ifndef
#define
#include<>
```

* angle brackets start checking library first then look locally
* double quotations marks, check local first
* keep paths relative
* every header file must have guards


### Standard pattern

```
#ifndef SOME_NAME_UNIQUE
#define SOME_NAME_UNIQUE

#endif
```

* definitions should be unique

## Put all declarations needed by other modules in header file
* any module referring to it must include the modules header file
* preprocessor replaces each include statement with contents of header
* dont **EVER** put using std namespace in headerfile because it forces clients
  to include this.

```
#include "Base.h"

class MyClass: public Base {

----------------------------
#include "C.h"
class MyClass{
  C c;
  C& c2;
}

class C;
class MyClass {
  C* ptr;
#include "C.h"
```

## Circular dependencies

* two or more header files depend  on each other
* forward declaration: notifies compiler that data or funciton will be declared
  or defined in the future, break circular dependencies

## Namespace etiquette

* never  place using directive inside of a header file or before an include
  directive in an implementation file, will pull in ALL members from the namespace and pollute class
* before an #include, will affect set of names visible to subsequent header

## Build process

* preprocessor, compiler, assember, linker
* tip: use #if 0 to debug code
* ~[Build Process](Images/buildprocess.png "Build Process")

## Separate Compilation

* use -c flag to build object files
* compiler smart enough, will add the appropriate ending
* can rebuild program only recompiling the files that changed and then linkingn together

## Compilation dependencies

* if f changes, need to recompile f and all files that depend on f
* executable depends on .o files

## Makefile

* make == unix command tha tuses build instruction and file dependencies, and file timestamps to decide which files to recompile/build

```
program.exe: main.o ADT1.o  #dependency graph
	g++ main.ADT1.o -o program.exe # Build rule
```

```
program.exe : main.o ADT1.o ADT2.o # default target
	g++ -g -Wall main.o ADT1.o ADT2.o -o program.exemain.o : main.cpp ADT1.h   g++ -g -Wall -c  main.cpp -o main.oADT1.o : ADT1.cpp ADT1.h ADT2.h   g++ -g -Wall -c  ADT1.cpp  -o ADT1.oADT2.o : ADT2.cpp ADT2.h ADT1.h   g++ -g -Wall -c  ADT2.cpp  -o ADT2.o
```

### Makefile with macros

```
CXX = g++ # = specifices not macro
CXXFLAGS = -g -Wall # flags
EXEC = program.exe
OBJECTS = main.o ADT1.o ADT2.o
all: ------ list of files dependencies
main.cpp: ADT1.h AD2.h
  ${CXX} ${CXXFLAGS} main.cpp ADT1.cpp ADT2.cpp

```

### Implicit rules

```
CXX = g++ # variables and initialization CXXFLAGS = -g -WallOBJECTS = main.o stack.o node.oEXEC = program${EXEC} : ${OBJECTS} # default target	${CXX} ${CXXFLAGS} ${OBJECTS} -o ${EXEC}# gmake knows how to build .o files; just list dependenciesmain.o : main.cpp stack.hstack.o : stack.cpp stack.h node.hnode.o : node.cpp node.h stack.hclean : # second target	rm -rf ${OBJECTS} ${EXEC}
```
* gmake has implicit rules for processing files with special suffixes

### Automatically derive dependencies
```
CXX = g++ # variables and initialization CXXFLAGS = -g -Wall -MMD # builds dependency lists in .d files OBJECTS = main.o stack.o node.oDEPENDS = ${OBJECTS:.o=.d} # substitute ".o" with ".d"EXEC = program${EXEC} : ${OBJECTS}   ${CXX} ${CXXFLAGS} ${OBJECTS} -o ${EXEC}clean :   rm -rf ${DEPENDS} ${OBJECTS} ${EXEC}-include ${DEPENDS} # reads the .d files and reruns # dependencies```
* -MMD generates a dependency graph for user source files
## Automated builds

* automated system incorporates all updated source files into exectuable
* incremental and only rebuilds  only what changed
* automatically derive dependency relationships among files

## Namespaces

package together related classes functions and types in common named scope

## Global namespace

implicitly declared in every program and includes all names defined at the
  global scope
`::membername`

## Unnamed namespace

declare a local namespace for file-scope names

## Referencing namespace members

1. using declaration: makes one name on par with local names, conflicts with
   local declarations of the same name `using std::cout;`
2. using directive: makes all of the names visible `using namespace std;`

namespace pollution: including lots of namespaces increases changes of
conflicts

# Lecture 5 cont

* Namespace pollution problem: clashes among global names in a large,
  multi-module, multi-developer program
* namespaces can be declared globally or nested within each other (but not
  nested in classes or routines)
* do not end with semicolon
* when spans files, acts as addition/appendix
* amount of namespace visible depedns on what is included

```

namespace x {
  int i, j, k;
}

int k;
void f(1) {
  int i = 0;
  using namespace x;
  i +=1;// local
  j+=1;// X::j;
  k+=1;// compiler error since ambiguous
  ::k+=1;//global
  X::k+=1;// X
}

void f2() {
  int i =0 ;
  using X::i;//illegal
  using X::j;
  using X::k;//hides gloval k
  i+=1;
  j+=1;
  k+=1; //x::k
}

//header1.h
namespace A {int f(double)}
//header 2
namespace B {using A::f; void g();}
//header 3
namespace A {int f(int);}

#include header 1
#include header 2
#include header 3
void B::g() {``
  f(1);
}

a) 1,2,3 => f(double)
b) 2,1,3 => none
c) 1,3,2 => both available, closest parameter, best math
d) 3,2,1 => f(int)
```
* order of includes hides certain variables

## Lookup rules for namespaces

* look locally first, within current scope
* look through enclosing scopes => search from innermost to outermost i.e.
  global

* search namespace(s) of routine parameters

# Lecture 6 Modules and interfaces

* module: software component that encapsulates some design decision
* interface: abstract public description of some module
  * supports info hiding
  * reduces information overload on client programmer
* best practice:
  * signature with syntatic requirements.
  * specificaiton with behaviour of module

## Modularization benefits

* support teamwork
  * define component boundaries
  * suppports parallel development
* make software development easier
  * supports decomposition into modules (or classes)
  * allows each component to be developed in isolation
* Simplifies change
  * consolidates information
  * code can change if only relies on other comopnent interfaces and

## Interface specificaiton

* preconditions: constraints that hold before the method is called (if not,
  anything goes)
  	* **requires**: necessary assumptions about the program state
* postconditions: constraints that hold after the method is called (assuming preconditions held)
	* **modifies**: objects/variables that may be changed by the method
	* **throws**: thrown exceptions, conditions leading to exceptions
	* **ensures** guaranteed side effects on modified objects
	* **returns**: describes return value
* contract between the module's provider and client programmer, that documents eaceh other's expectation
* document design of future module, document correct usage of existing module

## Vector example

* requires:
* modifies:
* ensures:vect.size  - 1
* returns: $ \sum_{i=0}vect[i] $

## Another example

* requires oldElem must be in vector
* modifies vect
* ensures: let i be the first index such that
  * vect(a)pre[i] = oldelem
  * vector[i] = new elem
  and all other elements are unchanged
* returns:  i such that vect(a)pre[i] = oldElem and vect[i] = newElem

# Yet another

*  need to worry about "corner cases"
  * empty strings
  * partial matches before actual match
* returns: true iff there exists a string (possible empty), A + B such that
  A word B == text

## Specifying Exceptions

* interface specifications can supersede exception specifications
  * lists all of the exceptions that can be thrown
  * specifies the conditions under which each exception is thrown
  * the precondition does not include the conditions that lead to a thrown exception

```
double quotient (int numerator, int denominator);   // throws:  DivideByZero, if denominator = 0   // returns: numerator / denominator
```

## Terminology

* An interface specification describes the behaviour of some software unit (e.g., function or class)
* An implementation satisfies a specification if it conforms to the described behaviour.
* The specificand set of a specification is the set of all conforming implementations.

## What are the conforming implementations
```
1. // works for all 3 implementations
  Requires: exists val such that vector contains val
  returns: position of element
2. // works only for 2
  returns: (j : vect[j] == val) ? j : -1
3. // works for 3
  returns: (j : vect[j] == val) ? j : vect.size()

4. // 2 + 3
  return (exists j : vect[j] == val) ? j : j < 0 or j>= vect.size()
5. // m usch stricter  so no
  return (exists j : vect[j] == val) ? (smallest j : vect[j] == val) : -1
```

##Class example
```
class IntStack {// Specification Fields:// top = top element of the stackpublic:  IntStack();     // ensures: initializes this to an empty stack  ~IntStack();     // modifies: this     // ensures: this no longer exists; memory is deallocated  void push (int elem);     // modifies: this     // ensures: this = this@pre appended with elem; top == elemvoid pop ();// modifies: this// ensures: if this@pre is empty, then this is empty // else this = this@pre with top removedint top();  // requires: this is not empty  // returns: top```
##Class example with hidden state
```
class Account {     // Specification fields:// ActNo = unique id of Account// balance = amount of money owed for phone services// fee = monthly feepublic:  explicit Account ( const AccountNo& num);     // ensures: initializes this to an Account whose// Actno == num// balance == 0// fee == 30virtual void bill ();// modifies: this->balance// ensures: this->balance = this@pre->balance + fee  virtual void print() const;     // modifies:  cout     // ensures:  cout = cout@pre + this
```
## Specifying derivations
* dervied classes not only inherit signatures but also signatures
* can list all specificaiton fields, inherited or new, or by just listing new fields
* when specifying overridden method, best to provide complete specificaiton

## How precise should a specification be

* **sufficiently restrictive**: rules out all implementaitons that are uncceptable to clients
* **sufficiently general**: does not rule out desirable implementations
* ![Specificand](Images/specificand.png "Specificand")

## Comparing specifications

* Specification a is stronger than b (a=>b) iff
	* a's preconditions are equal to or weaker(less restrictive) than b's preconditions requires b=>requires a
	* postconditions are equal or stronger if requires b=>ensures
	* a modifies the same or more objects
	* a throws the same or fewer exceptions

## Checking preconditions
* client responsible for ensureing preconditions satisfied before calling code
* best practice: throw exception if not satisfied, try to detect problem and report error

#Lecture 7

## Modifies vs const
* modifies: lists all data changed including global variables
* const: immutability checked by compiler

## Comparing Specifications

* one is necessarily better than the other
* i.e. each has a place
* strong: tolerant on inputs, demanding an outputs
* weak: demanding on inputs, tolerant on outputs
* a module with strong specifications can always substitute for a module with weak specifications

## Defensive Programming
* arrange for our compiler to help find programming errors

## Possible Failure
* errors: bugs, invariant violation, exposure of data representation
* misuse of code: client code violations of your preconditions
* external problems: non existent input file
* inappropriate file permissions, out of memory, memory corruption, hardware limitations(overflow, underflow)

## Assertions
* document and check assumptions
	* check preconditions
	* check postconditions
	* check representation invariants
	* check postconditions on called functions
* abort program as close to error as possible (then can use debugger to examine program state)

### Assertions in production code
* yes: don't want to risk the program corrupting persistent data
* no: may need program to keep executing, maybe bug doesnt have that many bad consequences
* can remove all assertions by compiling with preprocessor variable NDEBUG `g++ -DNDEBUG...`
* WARNING: assertions should not have side effects
* rule of thumb: use assertions everywhere

#### Aside
`-D` Flag has preprocessor commands

## Error Recovery
* goal: pass information from the point where an error is detected to a point where it can be handled

### Return values, global errror flags
#### Disadvantages
* passive/no enforcement of checking error value might have changed before check
* checks proliferate through code  + have to be maintained => inefficient
* could mix in valid  + error values => have to parse
* doesn't work for all situations e.g construtor fails
* testing has to be local, but may not be "right" level
* non-local error handling may need to pass up more than one error value => proliferation of errors

## Exceptions:
* lets separate error-handling code from "regular" code
* object thrown to represent occurence of error
* passes information from the pointer where error is detercted to a point where it can be handled
* called component reportsfailure by *throw*ing an exception
* caller component specifies which kinds of failures it can handle in *catch* clauses of a *try* block

### Termination exception handling model
```
try{

}catch(...){}
catch(...){}
```
* always go from most specific exception to least specific
* `catch(...)` will catch everything
* if exception is part of hierarchy, slicing bits off (catch by reference then)
* `throw;` reraises exception, does not examine other handlers
* generally when create exception, make it a nested class of the class that you are making the exception for
* can throw any type, usually better doing user defined types

### Standard exceptions
* programmers can define their own exception hierarchy or derive new exceptions from the standard exception hierarchy
* ![Exceptions](Images/exceptions.png "Exceptions")

|Class Name|
|----------|
| \<data\>|
|\<ops\>|

* DONT throw pointers to local objects (ends up w/ dangling pointer)
* type of object determined by type of pointer at compile time (**object slicing**)
	* takes static compile time type of pointer

### Catching an Exception
* code will continue after caught
* match the best fit
* handled by nearest handler whose argument matches the type of the exception object
* dynamically nearest client side code
* if no matchin handler, program aborts


### Stack Unwinding

As control transfers to an exception handler, it must pop off the call stack all the scope blocks that reside on top of the matching handler

* object in stack deleted for us automatically invoking appropriate destructors
* partially constructed stack-based objects are properly destroyed (objects fro filed constructors)
* if during stack unwinding a destructor throws an exception that it does not handle locally, the program terminates
* heap based objects needs ot be deleted explicitly

### Exception safety guarantees
* operation is excepiton-safe is it leaves program in valid state after terminating
* **basic guarantee**: basic invariants of all objects maintained, no resources leaked
* **strong guarantee**: basic guarantee + state of program reverts to what it was prior to call
* **nothrow guaranteee**: basic guarantee+ guarantee to not throw an exception
* can embed try catch in initializer list
```
MyClass::MyClass(C c, C* p2) try: c_(c), p_(new C), p2_(p2)
{...}
catch (...) { delete p; throw MyClass::Error();}
```
* c++ standard library provides:
	* at least basic guarantee for all operations
	* strong guarantee on a few key operations
	* e.g. push_back, single element insert on a list, uninitialized copy()
	* no throw on swap() of 2 containers  + pop_back()
	* works only if you don't leave things in an invalid state, don't leak resources + destructors can't throw exceptions (resources could be memory, files, locks, network connections, etc.)

## Smart Pointers
* raw pointers = data addresses with some type safety
	* still legal to access an object that's been deleted
	* delete object thats been deleted
	* delete object that another pointer refers to
* would like pointers to be smart enough to do the correct and obvious thing with respect to object deletion
* smart pointer i.e. `unique_ptr< >` is a templated object with internal pointer variable that points to heap object
	* class overloads the * and -> operators so it feel like real pointer
	* instances created as stack based objects
	* heap object allocated in constructor
	* destructor deletes heap object it points to
	* if exception raised, smart pointer's destructor invoked, which deletd heap based object

### unique_ptr

* exclusive ownership of a referent
* should be sole pointer to its referent
* canot be copied
* responsible for destroying referrent
* can release and clean if pointer isnt needed and wont be cleaned up for a while
* "Source and sink idiom" useful if creation/consumption
	* source creates a new version, sink deletes the object
* unique_ptr not same think as regular c++ pointer so can't assign one to other
* can't assign multiple `unique_ptr`  to same object
* can't pass as reference  for either parameter or return value; passing by value transfers ownership
* auto_ptr is deprecated; do not use - use either unique_ptr or shared_ptr/ weak_ptr instead

### shared_ptr

* shared ownership of a referent
* referent maintains a count of pointers referring to it
* when count reaches 0, object can be destroyed

### weak_ptr

* works with shared ptr and shares ownerhsip of a referent but does not contribute to reference count
* and test if the object has been destroyed and weak ptr is dangling
* need to convert to shared pointer to reference object

## RAII Programming idiom
* resource acquisition is initialization
* equates resource management with lifetime of object
* resorce allocated inside an object's constructor
* deallocated inside an object's destructor
*

##noexcept
* functions declare that they will not throw exceptions
* benefits programmer who doesnt have to provide try clauses
* compiler can optimize for no exceptions

## Exceptions vs assertions

* dont use exceptinos to report programming errors
* throwing an excpetion will unwind program stack and destroy local varaibles
* want progrma to terminate on exact line where the violation occured with the whole program state intact for our examination

copying be value will slice object in catch

* use assertions to check for logic errors
* use exceptions to report "environmental" erorrs i.e. if client input is in error since can be handled; wheras assertion violation would terminate program
* since assertion validaiton terminates program, right away helpful  since cause is "logically near" easier to debug

throw exceptions:

	* in constructor if can't create valid object
	* in mutator if try to set state to be invalid
	* ensure object is in previous valid state

never throw exceptions:

	* in destructors (hard to catch and deal with)
	* copy constructors + assignment operators
	* accessors
	* value operators e.g operator == operators< operator&&
	* try to aovi dmutating operators++

# representation invariant, Abstraction function

* have used pre and post conditions so far as client contract
* would like a more abstract form for ADT developer that would let swap implementations without breaking code representation independence
	* e.g. list as array vs circular, doubly linked list
	* let us reason about our code in a more modular fashion
	* helps catch erros and possible avoid them in the first place
	* often leads to cleaner code
	* leads us to representation invariant whic tells us if a type is "well formed"
* abstraction function is our tool to help us interpret the data

**interface specification**: contract between a module's provider and client programmer that documents each other's expecations about the module's operations(valid uses of operations, expected outcomes of operations, expressed in terms of module's abstract values)
**represenation invariant**: defines the set of valid concrete values of ADT's implementation

**abstraction function**: interprets legal concrete value as ADT's abstract values

## Set represented as an array
1. no duplicate values
$\forall 0 \le i, j < size \mid i \ne j \Rightarrow elements[i] \ne elements[j]$
2. above "size" pointers are  null
$ \forall i > size -1 \mid elements[i] == nullptr $
in remove set $elements[size-1] == nullptr$ before decrement size
initialize array in constructor

default-destructor causes memory leak, but doesn't violate representation invariant

list with dummy header node whose `(Data*) == nullptr` all other nodes have `(Data*) != nullptr`
	* must have a header node (i.e. not null)
	* data field of header node is null
	* node object pionter to by only one next + one previous field
	* for any 2 objects n1 + n2, if n1.next == n2 then n2.prev == n1
	* header node has null data field
	* list entries do not have null data fields
	* `Node(Data*, Node*p, Node*n`
	* check that data is not NULL

## Representation invariants of complex types
* if representation uses other ADT it may refere to them either by specification fields or by operations

## inductive reasoning
* invariant true for entire program, structural induction
* if an invariant of an ADT is established by constructor, preserved by mutators
* no representation exposure occurs
* then invariant is true of all instances of the ADT

## Representation Exposre
* non-private data members
* client has access to object insidet the representation through a different path
* operation outputs an object that is part of operation
* outputs internal collection
* outputs iterator that points to member of internal collections

## checking representation invariants
* check representation invariant on exit of constructor and on entry and on exit of accessors and mutators

## Abstraction function
explains correlation between concrete values in an ADT's impelmentaiton and the ADT's abstract values
* maps concrete values to abstract values

## idioms for expressing abs functions
* set comprehension: denotes the set of all elements x that satisfy the property
* recursion: most appropraite for recursive representations
* proejction: easiest to divide the AF into pieces
* by example: last resort

## Benevolent side effects
* move to front speeds up related lookup requests
* mutates concrete value but not the abstract value
* i.e. sort might help future operations

## Card example

suit = suit(index div 13) where S(0) =  ...
face = rank(index mod 13) where rank(0) = ACE

## UML

A model is an abstraction of somethign for the purpose of:
	* understanding it before building it
	* communicating it to others
	* answering questions about it

* typically on a smaller scale than the original
* different models elude different details e.g. TTC Map
* a software model can be more practical than source code for:
	* thinking + resoning about deisng decisions
	* group discussions about design  critiquing + improving design decisions
	* communicating design decisions to tohers

* source code has lots of irrelevant details + poor at depicting class relationships
* leads to UML

## Unified modeling langauge
* collection of notations for representing different views of a software design

### Structural Diagrams
* class diagrams
* object diagram

### Interaction Diagrams
* sequence diagram

# UML Class Diagram notation
* box represents calss and defines class name
* set of attributes( data fields, types), initial values, usually primitive types and stuff that isn't implicit
* set of operations(routines signatures)

### Abstraction in Classes
* classes can be epxressed at different levels of abstraction
* \+ public
* \- private
* \# protected
* *pure virtual*
* underline static
* might want to say stuff like read only

## Associations
* indicates there exists a physical or conceptual link between objects of those classes
* implies a long term relationship; not transient
	* e.g. parameter or return value
* i.e. rental agreement has a rented car, a person rneint int, and a date
* put role names which explains relationship between objects

## Multiplicities
* if not specified, multiplicity is 1
* constrain number of allowable links in an association
* for each object x of class X there must be at least p links of association R linking x to object of class Y
* can specify range of multiplicities m..n
* i.e. person has 1 arrow to a credit card
Deck 1-->52 Card
Student 1..*<---> 1..7 Course

```
Graph --->* Node --- 1 Building
         *|| /\ connects to
          \/  |
          Edge
```

## Implementing Associations
A --> *b usually pointer
A ==> 1
A => 5 B (should have 5 instances of B after constructor
a ==> * B Could be pointer
A 1 <==> * B (b needs a referene to A, one has to be a pointer)

```
Person -----
   ^ 0..1  |
   --------
```
 Have a base case to break cycle at some point
 self association

## Association Class
* class association represents link attributes
* properties of the link becuase they cannot be attributed to either of the end objects
* class association with a specific type
i.e. loan
```
Person ---- Book
        .
        .
        Loan
```

## Aggregation
* "part-of" relation between an aggregate (collection) and its members
* part can be a member of more than one aggregate
	* e.g. studnets can be members of more than one class roster
	* part has an idneity outside of the aggregate
* empty diamond

## Composition
* stronger "part of" relation between a composite object and its components
* part does not exits without its composite
* a part belongs to at most one composite
* composite is responsible for creating, destroying members
* has to treat as value so things cant change if being used by function

i.e. songs are physically stored in library, and playlists are virtual collections of songs

## Generalization
* subtype relationship between base clase and derived class
* every member of a derived class is a member of its base class
* attributes and associations of the base class are attributes and associations of derived class
* inheritance

## UML Object Models
* run time instance of a class model
* every object is an instantiation of a specific class
* every link is an instantiation of a specific association

## Uml sequence diagram notation
* graphical model of communication events between objects, ex exhibited by one execution trace
* show lifetime of object

# Design patterns
* patterns similar to recipes
* more concrete than principles which are like what ingredients go together, how cooking affects an ingredient
  more abstract than libraries(prepackaged solutions) e.g. package of buns,
  condiments, etc must be adapted to the situation
* help in situationas where we recongize a need to:
  * improve the design
  * refine the design
  * improve cohesion
  * loosen coupling
  * preserve information hiding
* but adds cost of complexity so don't use lightly
* often use clever indirection, interfaces, polymorphism, info diign of
  intermediate objects

## Gang of four design pattersn
* abstract oo designs that encapsulate change to improve modularity and
  flexibility of code
* increase cohesion loosen coupling, improve information hiding

## Inheriting common code
* algorithm to be set at compile time,
* hook to be at runtime (i.e. template call child methods)

## Template Method
* base-class method defines common code structure
* includes primitive operations to be defined by subclass methods
* essential that template method be nonvirtual, primitive operations are
  virtual functions in base class
* **Problem** multiple subclass methods have similar algorithm structures => duplicate code
* **Solution** localize duplicate code in an abstract class, which calls virtual subroutines which children can override

## Adapter pattern idea
* **Problem** interface mismatch between two modules
	* want to reuse an existing class, but its interface does not match what is
  needed
	* interface of one of modules changes and done want to break working code
* **Solution** define an adapter class that maps one interface to another
* example stl stack implemented by adapting interace of container class
* translates request made  to the target interface into request made of the
  adaptee object
* adapter design pattern coudl be for classes or objects; object adapter
  focusing on

## Strategy Pattern
* **Problem** want to vary algorithm at run time
* **Solution** encapsulate the algorithm decision
	* define algiorthm as a component object
	* use subclassing to specialize the algoirthm in differnet ways
* multiple strategies
* different algoirthms inherit from base algorithm
* all algoirthms need to use the same interface
* encapsulation of context date to be operated on
* different variants of an algorithm
* choose/change algorithm at runtime


## Strategy vs template method
* similar:
  * support differences in behaviour through encapsulation
  * customize smaller operations in algorithm
* differenes:
  * template method operations fixed at compile time, strategy changes
    behvaious at runtime
  * template method provides fixed framework, some suztomizable operations
  * strategy must follow interface, but behvaiour is customizable

## Problem: synchonized views
* want all view to update

### Solution 1: coupled design
*  what if need to add new display
  * will require code change
* dynamically change views at run time
* encapsulate changes to class

UML italicize abstract base class

* has at least 1 pure virutal method
* can't be instantiated

italicize pure virtual methods, not just vitual methods

Data Depends on interface not concerete
### Solution 2 Aggregation of Abstract views
views=>views can change
without affecting data, as long as interface doesn change can dynamically chage views

## Observer pattern
* problem: maintining consistency among related objects
* solution: subject sends updates to collection to abstract
  observers. subject maintains collection of subscribed
  observers, and sends notifications when state changes
* need to consider frequency of updates and amount of information
  * not all subscribers want all data
  * push versus pull  need to know observed accessors

### Different Design: Push vs pull
* in normal observer, subject pushes info
* alternative where each observer request data on notification of a change
* lets observers request info they need

### Concrete observers
* each concrete observer overrides update method to retreive and display info it cares about

Observer pattern minimizes coupling b/w subjects that publish information and observers that receive notifications of information

Subject just has list of observers, and observers just know it can get data

## Model View Controller
* combination of deign patterns to decouple UI Code from application code
  (model)
* Composite pattern: all view elements use the same uniform (abstract) base
  class
* observer: model and view implement observer pattern to nottify intereted
  objects of its state changes.
* strategy pattern: view delegates to controller the strategy that maps UI
  events to calls to model

view sends input to controller which manipulates model. model sends notify and then view sees notify and queries model for info. View finally updates itself

### Model
* holds data
* knows nothing about the view or controller

Java MVC examples on
https://www.student.cs.uwaterloo.ca/~cs349/s16/schedule.shtml
* note that tight coupling of Java GUI Api
* controller often leads to them being collapsed into one class
* View and maybe controller are observers of the Model
* note that the model encapsulates both the logic + the data of the domain
  model e.g. straights game
e.g. syntatic correctness of user command versus legality of move

# Object oriented design principles

* characteristics, properties and advice for making decisions that improve the
  modularity of the design

## Open Closed principle
* module should be open for extension but closed to modification
* program to interface but not an implementation
* have client code depend on an abtract class that can be extended rather than
  concrete classes
* dynamic polymorphism: at runtime
* static polymorphism
  - templates and generics
* hard because need to be able to determine what code belongs in interface and
  what can be overriden or not
* will need performance analytics to find bottlenecks
  * may need to restructure

## Default Implementaiton
* abstract base clas may provide default implementaiton taht derived classes
  may override, makes it easier to derive new classes
* abstract base class declares and define common data and operations

## Inheriting Interface vs implementation
* determine what parts of a member function the derived class inherits
1. interace( declaration) of member function
2. interface (default) overridable implementation
3. interface and non-overrideable implementation

## Inheritance vs Composition

Problem: when defining a new class that includes attributes and capabilities
of an existing class, should the new class inherit from the existing
class(inheritance) or include existing class as complex attribute (composition)
- "is a" vs "has a"
- square vs rectangle, not really substitutable

### choosing Interface
* favour inheritance when using subtypgin)face that a derived calass can be
  used anywhere parent
* using exsiting interface of existing class

### Choosing composition
* favour for simple non overriding code reuse and extensions
* components capabiltities (data and functions) can change at runtime

## Delegation
* object composition simulates inheritance-based method reuse
  * composite object delegates operations to component object
  * can pass itself as parameter, to let dleegated operation refer to
    composite object
* c++ private inheritance lets you have composition (from parent class object
  inherited) but private inheritance lets class have own interface (delegates
  by calling parent class methods)
  * no polymorphism i.e. not a subtype
* don't want long delegation chains (see "Law of Demeter")
benefits of composition maxmimized when components is abstract type

## Single Responsibility Principle
* encapsulate each changeable design decision in a separate module
* offers guidance on how to decompose program into cohesive modules

## Liskov Substitutability Principle (LSP)
* Derived class must be substitutable for its base class
* must preserve behaviour of base class so that it will work with client code
  that uses the base class
* accepts the base class's messages
* require no more than base class methods
* promise no less than base class methods

## Substitutability Rules
* when overridiing virtual functions, need to follow:

1. signatures: derived class objects must have all of the methods of the base
   class and their signatures must match
2. method behvaiours: calls to derived class  methods must behave like calls
   to the corresponding base-class methods
* properties: derived class must preserve all properties of base class objects

## LST Signature rules
* derived class must support all of the methods of the base class, and
  signatures must match
* parameters of overriden virtual methods must have compatible types as the
  parameters of the base class
* return type of overriden virtual

## LSP Method rules
* Method behaviours: derived class method maintainsor wearkens precondition and
  maintains or strengthens postcondition
* precondition rule :pre_base => pre_derived
* postdondition rule: pre_base && post_derived => post_base
* specification of derived class must be stronger than specification of base
  type
specification fo derived class is stronger than specification for base strength

## LSP Property rues
Property behaviours:
The derived class must preserve all declared (and enforced) properties of the base class objects.
- invariants(e.g.,no duplicate elements in a container type)
- optimized for performance(memory requirements, timing)

## Encapsulation of data  components
information hiding: modular design should hide design and implementation
details including info about components

## Law of Demeter
* tests encapsulation, object only talks to neighbours
* a method can only access data members of class, its data members or the
  parameters of the method call
* any object constructed by the class's methods
* don't call methods on constructed class's return values
###Advantages
* reduced coupling since you can't call methods on other objects
* reduces coupling between client code and supplied code
* simplifies interface makes it easier to understand
* testing: only need stub method, not stub classes, makes testing easier

### Disadvantages
* larger class interfaces
* performance penalty
* e.g. friendship is fast, delegation isn't
  * if design modularly, easy to do performance analysis and improve
    bottlenecks

## Checking if something is substitutable
1. check signatures
2. preconditions (smae or weaker)
3. postconditions same or stronger

## ASIDE
## Inheritance
*  static: fixed at compile time modify through interitance should use all
   parent class methods, else maybe replace rewrite parent
*  not easy to chnage, b/c may need to change parent
*  limited flexibility unless you use abstract classes. some or no
   implementation
   hierarchy could become huge
* may be defined in one class

## Composition
* dynamic: changeable at runtime
* modify through inheritance
* use what is needed
* already relies on interface
* object encapsulates behaviour helps focus on single responsibility, fewer classes, more objects
  dpeends on object interrelations
  system behaviour depends on object iterrelationships

# Refactoring

* there is some argument as to how useful practice of refactoring is i.e. is
  the improvement worth the effort
* there aren't too many formal studies mostly anecdotal evidence
* key temet of extreme programming
* should make the software easier to understand and modify; otherwise it's not
  "refactoring"
* the imrpoved understanding should make it easier to spot bugs
* performance optimization oftenm makes code harder to understand, but
  necessary tradeoff for the speed improvement
* code loses structure over time as people make changes
* change made to internal structure of software to make easier to understand and modification easier
* improve design
* change structure while preserving semantics
* improve design, consolidate duplicate code, improve cohesion, lessen coupling
* RERUN TEST SUITE AFTER EACH CHANGE TO HELP ISOLATE ERRORS
* do not change functionality, should not effect output, dont fix bugs or add
  features
* system level tests should not have to change after refactoring (should not have changed externally visible behaviour)
* unit tests would be changing a lot as moving contents aroudn
* do not publish interfaces too early since if they change, dont want to make
  clients change their code, now have to support legacy code

## Technical Debt
* technical debt: something you ought to repay by cleaning up/refactoring desing,  putting off design changes for later, will have to pay
* developers usually forced to work aroudn bad designs, too much risk changing a design that works (not viable in a business sense)

### how often
* as you develop, in iterations
* no hard and fast rule
* usually, when you add a function, fix a bug, do a code review

* if you do fix a bug, improve unit testing to make sure bug doesn't reproduce

### When not to refactor
* dont' change design radically, because people need to relearn what the
  system is about
  * chagnes break mental model other develpoers have of the code (will have to relearn the code)
* expensive time consuming and requires a lot of testing
* cheaper earlier rather than later
* if it would be easier to just rewrite  to help avoid errors (if you don't have tests)
* code is buggy and not worth saving
* close to deadline and don't want to incur risk
* usually refacotr sooner rather than later since less risky and less expensive

## Rule of three
* first time you code a task do it
* second time you rwrite it, code it up again, keep in mind
* third time you code the same idea, refactor
* practive **Just in time abstraction**: dont try to make most abstract system possible, expect that you will be rearranging code constantly

dont know all of them, just starred ones and general ideas
extract method,
pararmeterize method
replace type code with class
separate query from modifier
replace conditional with polymorphism

## Case Study
* rental points
* object envy: always looking at another classes infomration, probably in wrong
  place
* return arental.getCharge();

### Extract method
Pull out functionality that is intertwined into other code that can be separated into its own function. Avoid putting too much logic in one method.

### Rename variables
Makes it easier to read and more meaningful to read.

### Move Method
* method using or used by more features than in the class it is defined
* change who owns the method

### Replace temp with query
Instead of using temporary variables, simply call functions multiple times since cleaner

### Replace conditional with polymorphism
* prevents open for modification where parent class has to be able to support specialized child operations (instead use template)
* just call specialized behaviour rather than check for properties of object

## Bad smells
### duplicated code
* same expression in two methods of the same class, in two sibling
    subclasses(pull up method to parent class), methods doing the same thing
    with a different algorithm(subsitute algorithm), duplicate code in two
    unrelated classes (maybe extract class and use the new component in the
    other or even make a strategy)
* (depends on where the code occurs):
  * apply extract method
  * sometimes make template
  * with different algorithsm might want to use strategy

#### Might duplicate with templating, naturally follows the pattern and can make a case for using the design pattern
#### Also in libraries and when making boilerplate

### Long method
* break up into smaller methods (extract method)
* delegate subtasks to sub objects that know best how to do something(template
    method, can extract class/method)
* avoid temp variables and long parameter lists as it makes code hard to
    read(replace temp with query) (replace parameter with method[let method
    take care of it], introduce
    parameter objects)
* extract conditionasl and loops (put into diff methods)
* maybe encapsulate things and wrap up
* where there are comments might be able to turn into another method
* use objects to wrap parameter

### large class
* class trying to do too much (has too many instance variables)
* try to elliminate redundancy
* extract class, extract subclass, extract interface
* sometimes,need to be large (i.e. a library class need a large interface and has lots of overloading)

### long parameter list
* make methods difficult for clients to understand
* trying to do too much

### divergent change
* one class commonly changed in different ways for differnet reasons
* develop god complex(acquire details/ownership of subparts that belong elsewhere) -> poor cohesion
* can break stuff up, reshuffle and reconsider relationships

  "one class that suffers many kinds of changes and shotgun surgery is one
  change that altes many classes. want to ararnge things so that there is a one
  to one link between common changes and classes"
* class trying to do too much  contains many unrelated subparts
  * over time a class acquired detail, ownership of subparts that belong
    elsewhere
  * un related elements

### shotgun surgery
* opposite of divergent chagne, each time make a coherent chagne, need to change lots of classes in little ways -> poor cohesion
* try to gather stuff in new or existing class

### feature envy
 * method seems more interested in another class than the one it's defined in
 * move parts that it wants, into it so it is more cohesive
 * exception with design patterns where trying to decouple algorithm from data

### primitive obsession
  * all subparts are primitive types
  * small objects have non-trivial contraints that can be modelled
  * can create subclasses that can validate and enforce constraints to make system more strongly typed(delegeate some responsibility away from class to ensure data is correct)

### lazy class
  * doesnt do much different from other classes
  * i.e. several sibling classes that don't exhibit polymorphic behavioural differences
  * can just collapse back into parent and add parameters
  * can be residual after refactoring gutted class of interesting behaviour

* automated support for refactoring (ides help ease pain)

### Automated testing
* for every new feature, add relevant tests and rereun all previous tests (easier when automatic)
* help know when and where stuff breaks

# Midterm clarification
* composite class made up of other classes, actual relationship between classes
  is categorized as one of: association, aggregation, composition(from weakest
  form to strongest)

# Facade and Composite

## Facade
* Problem: Complex interface
* Solution: single simplified interface, restrict and simplify clien't
sinteractions with subsystems classes

## Object composition
* compound object: represents composition of heterogeneous recursive components
  objects
* law of demeter comes in play

###Approach 1
* client interacts with "head object" that provides services, mostly through
  delegation
* must advertise all possible services
* use principle of least knowledge
* client only interacts with the composite object

## Composite design pattern
* gives client access to all member types in a compound oject via a uniform
interface
* one single interface through abstract base class
  * must advertise union of leaf and container services
  * client interacts with root composite object that could be of any type in
    the composite heirarchy
* operations applied to the root might be applied recursively on the members
* problem: object consists of several heterogeneous parts (client code
  complicated by knowledge of object structure, client code has to change every
  time the data structure changes)
* solution: create uniform interface for the object's components
  * interface advertises all operations that components offer
  * client deals with new uniform interface
  * interface is union of the components' services

![composite](.images/5f48e0d4-bd9c-4ff3-aac1-9421f5b2ae20.jpg "composite")

### Leaf class
* override behvaious of leaf object operations

```

void Developer::print() {
  TeamMember::print();
  std::cout << ", salary=" << salary << std::endl;
}

```

## Uniformity vs safety
* whether to include component specific operations int he component
  interface involves a trade-off between
  **uniformity**: preserving the illusion that component objects can be treated
  the same way (promoted by composite)
  **safety**: avoiding cases where the client attempts to do something meaningless, like adding components to Leaf objects (promoted by liskov substitutability)

```
class Expression {
public:
  virtual string name() const {return "";}
  virtual const Exprssion *left() const
  virtual const Exprssion *right() const
  virtual int value() const {return 0;}
  virtual void print() const {}
}

class Variable : public Expression {
public:
  Variable(string, int);
  string name() const;
  int value() const;
  void print() const;
}
```

Adding new functionality is hard because have to change entire hierarchy.
easy to add new leafs and composite types

client only deals with uniform interface easy to add new leafs and composite
types, though new operations are harder to add

clean up client but still have to know what type of composite it is

should be used mostly when the client treats the structure uniformly, if there
exist reasonable default implementations of operations

alternative to composite is to keep element types distinct

# Iterator Design Pattern

* Gang of four visitor desing pattern overlays/ uses the iterator to travers
  and apply an encapsulated operation to a Composite object (application of the
  Composite design pattern)
* iterator also known as cursor

![iterator](.images/7c93c14e-2d7a-4c52-bdc6-119079399e6f.jpg "iterator")

## Iterator
* provides way to iterate through element of a collection of objects without
exposing the underlying represenation of the collection
* moves responsibility for access and traversal order into a separate iterator
  object

Iterator provides two hooks
1) is there more information
2) obtain the next piece

### Motivation
* want to apply a funciton to all items in a collection
* want multiple simultaneous traversals of the collection

Collection will have to know how to create iterator, will have to know when at
the end of collection
WRT iterator itself, some idea of where they are in the collection

Need to retrieve information form the actual object

Need new concrete class to implement different type of  iterator

## Iteration over a composite object

* more interesting case is when the aggregate is a composite object where it
  needs to construct an iterator that understands and navigates the composite
* needs to be able to navigate leaf and composite object
* both iterators for composite shoudl extend a common parent with some common
  methods that both iterators export

Cant get out of coupling since somebody needs to know the structure of the
item being traversed

## client code
see slides

For team iterator, create iterators every one of the children
Doing a bfs on elements

What if we want to travers in opposite order?
first() is now the last element, i next gets the ith child determine by cursor,
cursor stops at -1

What if we want traversal to only return laves?
first -> doesn't change
next() in check for cursor == -1 // start of iteration
ask TeamMember::size() if == 0 -> delete iteartion node & return element

Who is responsible for calling next() and hasNext()?
1) client (external iteration)
- client applies operaiton to retrieved item
2) iterator (internal iteration)
- client gives operation to perform e.g.(functor), pass lambda fnciton to
  iterator to perform
- visitor

Who defines the traversal algorithm
1) composite
store cursor
2) iteartor
store cursor
3) visitor
store cursor

Dont want composite to change during iteration
How can we deal with this?
- don't allow it, hard to work with in multithreaded encironemnt wihtout langauge
features
- iterator takes snapshot of static information (costly)
- buffer up  changes while iterator is active
- buffer changes while iterator is active then, commit chagnes(but in pracgive
  buffers are finite in  size -> finite commands; waht to do if more ? cost of
  storing)

More complicated data structures require more complicated traversal algorithms

# Decorator and factory

## Decorator
* Problem: treat features as incremental enhancements of object
* allow arbitrray combinations of features with minimal impact on existing code
* ideally want to be able to make changes dynamically (e.g. turn on/off
  separately + dynamically)
e.g. telephones with call waiting caller id call forwarding, speed dial, etc
e.g. game characters's appearance power ups
Dont want to use inheritance since N features requires $2^n$  possible classes
all of which need maintenance
Need an abstract base class (ABC)
* provides interface
* may want to use template method design pattern to ensure parent class methods
  are invoked

## Composition and interfaces
* composition and the programming to an interface desing idion let us change
  window properties dynamically
* window calls draw on title bar calls draw on scrollbac calls draw on window

### Key ideas
* need instance of ABC but want polymorphic behaviour -> reference or pointer
* need to be careful to delete object when you allocate on heap
* need common interface of operations even if action for a particular concrete
  class is a "NOP"  i.e null operation

## Decorator pattern
* decorator(Wrapper) objects intercepts call to nested  object
* can add functionality before it invokes component's  operation
* add functionality after invokes components operation
* can decide not to call components operation
* can add new operations
* using composition to build a wrapper
* wrapper implements new functionality and includes original object as
  a component
* decorated objects are created by instantiating features and passing them the
  component object

![decorator](.images/91417a15-63cd-4ecf-864e-aa957a454994.jpg "decorator")

```
class Decorator: public VisualComponent {
 public:
  void draw();
  virtual ~Destructor();
 protected:
  Decorator(VisualComponent* vc);
 private:
  VisualComponent* component;
}

Decorator::Decorator(VisualComponent * vc): component(vc);

void Decorator::draw() {
  component->draw();
}

Decorator::~Decorator() {
  delete component;
}

VisualComponent * vptr = new TitleBar(new VScroll(new HSCholl(new FileListing())));

vptr->scroll();
```

## Reserved Library Items
Q: what if you want to electronically check out an item?
A: easy to add as a decoration but need to add a electronic check out operation
to ABC LibItem
* eCheckout(Patron)
* check # licenses (> 0 ), is one available

To undecorate:
  * need reverse lookup that maps object address /id to decoration

  or

  * embed id  value for characteristic

* add operation to root ABC
  * if found and we are at the thing we want to remove, set this to the
    component of the decorated class and return the result
    if component is null ptr return nullptr
    return component->removeDecorator();

## Instantiating Objects of concrete type
* prgramming to interface not implementaiton hard to follow when creating new
  objects cannot instantiate abstract objects
## Motivation
since every object oriented program creates objects, its likely extend program
by adding new types, factory may be most usefule design patterns
* encapsulation fo what changes is now applied to object created to minimize
  amount of change
* factory method used for single hierarchy , abstract factory used for families

### Approach 1: Encapsulation
* encapsulate code that creates concrete objects in a simple factory

### Approach Factory method pattern
* create factory which knows how to create each type of student
* have pointer to concrete factory, reasonable for it to be singleton to create
  a factory
* encapsulate code that creates concrete objects
* use template method
  * abstract class defines a method (template method)
  * factory method primitive operation of the template method
  * subclasses overrride factory method to construct specific concrete obbjects
* just plug into new factory

![factory](.images/f57d44c0-e954-4604-a275-abade7b51d02.jpg "factory")

```

class Registrar {
public:
  void admitStudent(const std::string name);
private:
  virtual Student* create(const std::string name) = 0;
}

void Registrar::admitStudent(const std::string name) {
  Student * s = create(name);
  s->welcome();
  s->invoiceTuition();
  s-> createTranscript();
}

class EngineeringRegistrar::public Registrar {
private:
  EngineeringStudent* create(const std::string name) {
    return new EngineeringStudent(name);
  }
}

// pretend have as virtual method
void EngineeringRegistrar::welcome() {
  Registrar::welcome();
  s->giveHardHat();
}
```

## Polymorphic Factory
* find appropriate factory to construct a certain type of object

## Concrete Classes
* need the polymorphic factory to be a friend

## Abstract Factory
Provide an interface for creating families of related dependent objects without
having to know the details of the concrete classes
* i.e. windows managers tell how to create objects, then concrete factories for
  each manager
Localization adaptation of a product or service to meet the needs of
a particular language, culture or desired populations "look and feel"
* abstract factory points to concrete facotry that points to all product which
  each specify their own specific implementation

# STL Containers
* stl is a major compoennt of c++ standard library
* stl operations not virtual
* mostly generic containers so we can use with our classes
* different kinds of iterators that can navigate through the containers
* algorithms that perform operation on range of elements

## Design philosphy
* almost any algorithm can be used with any container or any other data
  structure  that supports iterators
* generic containers
* useful efficient algorithms
* value semantics for contained elements, elements copied to/from containers
* designed to be efficient
* no inheritance, designers though inheritance was wrong and that generic
  programming better at polymorphism flexibility reuse
* container methods are not virtual to improve efficiency

## Polymorphic containers
* need to use pointers to prevent dangling pointers
* need to have some iteration to free variables

## Containers of objects or pointers?
* object copies everything so expensive operations, changes to one object do
  not affect another, risk of static slicing
* pointers: allows for polymorphic containers, only pointers destoryed need
  manual cleanup

## Containers
1. sequence containers: vector, deque, list
2. container adapters: stack, queue, priority_queue
3. ordered associative containers: set map

* deque: double ended queue wihtout similar to vector
  * allows fast direct accessplus easy growth at either end
  * like vector, slow to insert/delete from middle
* list: plain old doubly linked list
  * has backward/forward iterator but no direct access
  * once have found right spot, fast to insert/delete from middle
* set: mathematical set
  * multiset allows duplicate elements
* map: associative array, can index by almost anythign
  * multimap allows the same key to map to multiple values

can add index to vector to go to specific element

```
vector<int> v;
v.erase(v.begin() + 3);
```
* vector reallocates when size reaches capacity using 'doubling' where actual value is some sort of constant
  * copies all objects over
  * anytime insert at beginning /middle, remove from beginning/middle, need to
    copy over (a portion) of objects

## Sequence containers
* total ordering of contiguous values  (i.e. no gaps) on elements vased on the
  order in which they are added to the container

1. differ on access methods
* vector and deque allow random access to elements but list only allows
  sequential access (via iterators)
2. performance
* vector and deque optimized for random access retrieval

## Vector<T>
* expandable array that suports access within bounds
* must be stored contiguously so has to be implemented as c style array
* calling push back when at capacity forces reallocation

## deque<T>
* double ended queue
* fast insertion and deletion at beginning and end
* random access fast but no guarantee elements are stored contiguously
* periodically adds/removes chunks but cost is smaller since only manipulating
  part of the deque
* cost of copying pointers ot chunks is less than copying objects + not counted
  in overall cost
* random access cost slightly more than vector since need to find right chunk
  first
## vector vs deque
* if need to insert at fron tuse deque
* if need to insert into middle, use list
* random access to elements in constant tie in both, but vector may be faster
  in reality

### vector:
if know initial size for vector, use `reserve()` to get correct size allocated
initially want optimized random access iteration, iteration and append
use deque if dont know initial size and want to optimize random access
iteration + append/prepend

## list<T>
* fast insertion/deletion
* supports sequential access to  elements via iterators

## std::array
* thin wrapper around c++ array
* not implicityly converted by compiler into a pointer
* supports `at()` and `size()`
* strong typing, enforced size
* array contents stored on stack vs heap
* faster and more space efficient than vector

## std::forward_list<>
* singly linked list
* a little more space efficient

## Container adapters
* trivial wrapping of sequence container to provide specialized interface with
	adt specific operations
* can specify in constructor call which container want to be used in underlyig
	implementation
* implemented iwth adapter design pattern
* define operations by delegating to operations form workhorse class

Bad idea usually to inherit from stl container

## Stl way
*  inheritance might be better in some situations but enforces adaptation since
    no virtual methods
* most needs satisfied by STL container classes

## public inheritance
* inside class definition of circle, had direct acces to all non-private
	members
* children have superset of the parent classes public interface

## Private inheritance
* direct access to all non private members
* not subtype, does not support public interface of what it is inheriting
* cannot treat it polymorphically
* reuse base class implementaiton without having to support base class
	interface
* all inherited public and protected members of base class are private in the
    chidl class and can be used to implement child class methods, but not
    exported to the public
* can use using directive to promotoe container methods and types to be public
    * breaks polymorphism so safe, no risk of calling wrong methods, cant call
    parent methods

```
Figure::draw();
```

## Associative Containers
* use tuples (>= 1 heterogeneous piece of data groupted together conceptually)
	* (key, value) pairs

### ordered associative containers [multi]map , [multi]set
* ordering of elements based on key value and not order of insertion
* implemented using binary search tree (lookup O(logn))
* can iterate thorugh container elements in order

### unordered associtaive containers (c++11) unordered_[multi]map, unordered[multi]set
* no ordering assumed among the elements
* implementd using hahs tables (lookup O(1))
* can iterate thorugh container elmenet but no particular ordering is assumed

key must have operator==, opeator < defined

## set <T>
* collection of unique values
* must support comparison function with strict weak ordering
	* anti-reflexive, anti-symmetric, transitive
	* default is operator<
	* ned reasonable ordering function to the set constructor
* do not allow duplicate elements
* insert element presetn in set the set is unchagned
* returns <iterator, bool> where bool is success, and iterator is position of
	new element

## Equality vs Equivalence
* equivalence: container search methods (find count lower_bound) will use !< and !> to check if
	elements are equial if if have own definition of operator==
* equality is used by stl algorithms (find, count_if, remove) using operator==

## map<key,T>
* maps key to unqiue value
* `map <T1, T2>  m`
* T1 key field type, support comparison funciton with strict weak ordering
	(default is operator`<`), can use user-defined class, but must ensure
	reasonable operator `<` defined or provide an ordering functor to the map
	contsructor
* T2 value field: can be anything copyable and assignable

## Querying map for elment
* lookup using array indexing like operator
* can use find to return an iterator

## how are they implemented
* usually red-black tree
* no operations for direct element access, cannot change value of element
    directly need to remove and then reinsert
## Unordered set and map
* provide iterators but no interesting order
* fast O(1) access

## Iterators
* represents abstract way of walking though all elements of some
	interesting data structure
* given pointer to first element in the collection
* pointer to just beyond the last element so we can stop when we get there
* way of advancing to next object in collection.
* nested dypes, defined inside the respective container who
	understands what ++ means

### Kinds
* input iterator, output iterator
* input iterator: read only where each iterated locaiton may be read only
	one
* output iterator: write only where each iterated loaction may be written
	only once
* forward_iterator: can read and write to the same location repeatedly
* bidirectional: can iterate backwards and forward
* random access: can iterate backwards and forwards, access any element
	iterator arithmetic

![iterator_stl](.images/a66517df-47f1-4761-8472-430f6a0981db.jpg "iterator_stl")

### Insert iterators
back_inserter: uses container push_back
front_inserter: uses container push_front
inserter: uses conatiners insert

# Algorithms

* collection of algorithms that know nothing about data, know almost
	nothing about the elemenst in the structures, operate on structues
	sequentially via iterators
* process sequence of data, traverse data bounded by two iterators
* operate on each data element

## Duck typing
* object of class C type-compatible with a template parameter type T fi
	supplies all methods/method signattures used in the template

```
template<class InputIterator, class T>
InputIterator find(InputIterator first, InputIterator last, const T& val)
```

## Iterator Type hierarchy
* iterator type hierarchy based on  "duck typing", sub set of
	capabilities of the iterator
* any stl algorithm that requires inputiterator as a parameter also acceps
	fancier iterator in the type hierarchy

## Non modifying Algorithms
* read, never write to elements
* i.e. find

## Algorithms over two sequences
* specify full range of first sequence and only start of the second
	sequence
* i.e. transform

## Modifying Algorithms
* overwrite element values in existing container
* take care to ensure that desination sequence large enough

## Overwritign vs. Inserting
* overwrite existing element is default behaviout
* can impose insertion behaviour by providing inserted iterator
* i.e. "std::back_inserter"

## Removing Elements
* Algorithm never directly chagne size of containers, need to use
operators to add/remove elements
* instead algorithms rearrange elments, place undesirable elements at the
	end of the container and returning an iterator past the last valid
	element
* i.e remove move elemnts matching predicate to back of vector and then
returns iterator to first element of range
* can now use erase on range

```
vector<int>::iterator end = remove(vec.begin(),vec.end(), 42);
vec.erase(end, vec.end());
```

## Algorithms that apply operations
* apply operations to elements in input range
* transform, count_if, sort
* some stl algorithms accept predicate that can be applied to all
	elements in iteration
	* restrict set of data elements operated on

## Function objects
* need a funciton that refers to data other than the iterated elements need
	to define funciton object (functor)
* class that overloads `operator()` function call operator
* `operator()` allows any object to be used with fnction call syntax

## Transform
* essentially map, take range ranges and start of third range, and start of
	range to put modified elements
	* also predicate or operation to perform on data

## Classifciation of funciton objects
**Generator**: takes no argument,s returns value to arbitrary type
**Unary Funciton**: takes single argmentt and returns value that may be of
different type (which may be void)
**Binary function**: takes two arguments, returns value of any type
**Unary Predicate**: unary function returns bool
**Binary Predicate**: binary function returns bool

## Predefined function objects
* function provides some usefule generic funciton objectso
* plus, minus, times divides, equal, geater

## Predefined function object adaptors
**bind1st**: convet binary function to unary function by fixing first operand
**bind2nd**: convet binary function to unary function by fixing second operand
**mem_fun** convert member funciton  into fnction object (member function
called on pointers to objects)
**mem_fun_ref**: convert member function into function object( when member
function is called on objects)
**not1**: reverses truth of unary
**not2**: reverses truth of binary
**ptr_fun**: convert function pointer to a function object sot hat a generic
adaptr can be applied

## Adaptable function objects
* must provide nested type definition for its arguments and return type
* function object adapters are function objects

# Lambdas
* ease task of writing funcitons, inline functions
* can use bind to unify a number of funciton adaptor from c++03
* mem_fn unifies function adaptors mem_fun and mem_fun ref for accessing member
    function fo iterator referent
* can be used anywhere a callable object is expected
```
[capture_list](paramlist) -> return type {function body}
```
* capture list lists local variables used within funciotn
* parameter list usual funciton parameter list
* return type can be inferred
* funciton body is normal

* can call as normal function since overloaded `operator()`
* can be stored as variable  and bariable can be used as function pointer

## Capture list
* lambda can create unnamed adhoc functor initialized by capture list
* closure
* referes to value of local variables at point of lambdas creation
* lambdas can capture variables local in scope from the labmdas point of
    declaration
* can capture by reference with &
* can see the function parameters of the funciton within which it is defined
    * cant capture global variables, local static-lifetime bariables, or class
    member variables (but we can fix this)
    * function call operator is defined as const by default so need to declare
    lambda as mutable
    * if want to be able to modify the captured variable in teh lambda body[]()
    `[]()mutable -> {}`

## Captures by reference
* lambda holds reference to actual variable
* can bind

## Gotchas
* captured reference only valid if the referred to variable still exists
    (dangling pointer)
* by default, lambda may not change value of captured variable that it copies
    by value, need to add mutable keyword
* using lambdas inside member fnc data  members not local variables and cannot
    be captured
    * can fix by capturing `this`

## Bind
* replaces a number of adpaters and binders
* funciton template that create and returns a function object that "wraps"
    a supplied function in the form of a function pointer
    * usually used to reduce the number of call arguments by binding
    replacement (i.e. variables constnats)
* functor adapter used to associate function parameters with particular
    arguemnts or values
    * usually to reduce nubmer of arguments that need to be provided when function
    called

### Syntax
* `bind(function pointer, bound arg)(call arg)`
* bound arg: list of argument values bound to function parameters
* call arguments: arguments provided when function called
* retugnin function object that stores pointer to function as data members,
    coies boudn arguments and store them as data members, overloads operator
    (), uses saved argumens as function arguments

### Call be reference
* bound arguemnts copied to and stored in function object
* when binding, modifying copies
* If bound to a call-by-reference argument in the function, the functor’s internal copy is modified (but not the original program variable)
* need to call with reference wrapper class `ref(variable)`
* makes copy of reference varable so internal copy

```
void write_int(ostream* os, int x) {
    os << x << endl;
}

auto wi = bind(write_int, ref(cout));
wi(5);
int i = 10;
vector<int> v;
for_each(v.begin(), v.end(), wi);
```

### Reference wrapper classes
* can modify bound program variable by wrapping argument int a reference
    wrapper class
* `ref()`

### Placeholders
* binding subset of function arguments allowing others to be set by call arguments
* use placeholders to indicate which call argument maps to a particular
    function parameter

`void inc ( int &x, int amount ) { x += amount; }`
* if bound argument is a wrapped reference to a modifiable location (an
lvalue), the function can modify itp
    * bind ( inc, ref(i), 100 ) ();
* if call argument maps to reference parameter, the function can modify it
    * bind ( inc, \_1, 100 ) ( i );
* if argument is not modifiable location (e.g constnat literal, expression
    function call) get compiler error
    * bind ( inc, \_1, 100 ) ( 5 );

## Binding member fucntion
* must provide pointer to member function
* must provide, `this` argument  (object whose member function is being called)
* need to pass ref if want to not modify copy

## mem_fn
C++11 also provides mem_fn that adapts a function pointer for an object’s member function
* easier to use than bind if there are no arguments to bind
* works for colleciton of objects and pointers to objects
`for_each ( list.begin(), list.end(), mem_fn( \&Balloon::pretty_print ) );`

# Templates
* template is a blueprint; compiler uses it to generate type specific versions
    of the class/function. The generation process is called "instantiation"
    * creates a new instance. happens when we call or use it to initialize or
    assign a pointer to a funciton
* when we use a function template, compiler will usually infer the arguments
    for us; but must have an exact match  if have multiple parameter arguments
* compiler will perform "const" conversion as necessary if defined to take
    a non reference type. If parameter isnt a reference type, will convert
    array or  function to a pointer

## Overloaded functions
* problem is that code in overloaded functions whose bodies are identical
    except for the types
* typename and class are interchangeable, should use typename since more
meaningful
* may see class in older code
* convention is to use T for type

```
template<typename T>
```

Function template describes family of functions

## Template argument deduction
* if template type parameter used for more than one function parameter, the
    deduced types for the call arguments must match, otherwise it is an error

* if have multiple types  T1, T2, etc
```
template<typename T1, typename T2>
int compare(T1& v1, T2&v2) {
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

```
template<typename T1, typename T2>
T1 sum(const T2&a, const T3 &b) {
    return a+b;
}

// will work
float f = sum<float>(10, 3.14);

// error cant infer enough
long f1= sum<float>(0, 1.5);

long  f2 = sum<long, int, long> (0, lng);
```

## Class Templates
* define a generic parameterized class
* same as for functions

* template parameters follow normal name-hiding rules
* `template<typename T>` hides any global definition, gets instantiated type
* cant redefine T within the template `typename double T;` or repeat in
    parameter list `template<typename T, typename T>`

## non type template parameters
* can have non-type template parameters, which are treated as compile time
    constants
`template <typename T, int size = 100>`

Friend declarations can use a different type parameter than the class itself.
Eastablishes a many to one relationship between each class instantiation and
its friend i.e. for any one instantiation of class, all instnatiations of
routine are friends

```
template<typename T> class Stack;
template<typename T> ostream& operator<< ( ostream&, const Stack<T> &);
template<typename T> class Stack {
friend ostream* operator<< <T>(ostream&, const stack<T>&);
};
template typename<T> ostream& operator<<  (ostream& os, const Stack<T> & s) {
    return os;
}
```

## Friends
There are 3 kinds of friend declarations that may appear in a class template

## Duck typing
how the template definition uses varibles of type T will impose some
requirements( no type safety)

pass by reference ( or const reference if not supposed to change)
    * more efficient than passing by value (for objects)
    * safer since compiler catches errors (e.g. try to change refernce address)
* initialize construtor's type parameters in initializer list -> more efficient
    if class type sicne doesn't invoke constructor twice
* usually pass in classes by reference

Compiler catches:
    1. simple syntax eror (# arguments, semicolons missing etc)
    2. (instantiation) compiler can check argument types match or not more
       stringer # and  type of parameter
    3. in step 3, type errors, such as provision of operations which may only
       be caught when linking

Some compilers alterntly maintain a repository of teamplate instances

## Variadic templates
* some unspecified number of parameters
* kinda like java
